/* -------------------------------------------------------------------------- *
 *                                  QCDyn                                     *
 * -------------------------------------------------------------------------- *
 * This is part of the Quantum Classical Dynamics (QCDyn) program.            *
 *                                                                            *
 * Author: Zhubin Hu @Sun Group @NYU-SH                                       *
 * Last updated: Dec. 16, 2021                                                *
 * -------------------------------------------------------------------------- */

#pragma once
#include "Tools.h"
#include "Parameters.h"

/**
 * This class defines Non-Markovian transfer tensor method (TTM) [1].
 *
 * TTM is formally related to the GQME-based approach, but it has the advantage
 * of being significantly easier to implement in practice. It doesn't propagate
 * phase space, but can simulate the reduced quantum subsystem dynamics directly
 * from the transfer tensors. Within TTM, solving for the reduced dynamics of
 * the quantum subsystem, is accomplished via a straightforward matrix multiplication
 * procedure. The transfer tensors can be obtained from short-time dynamical
 * maps via the iterative procedure [1]. The dynamical maps can be extracted from
 * a short time reduced density matrice at the discretized times (starting from
 * all possible initial states, therfore the number of needed density matrice is
 * DOFe*DOFe) (so-called learning period) that generated by any dynamics.
 *
 * TTM has already been successfully applied to TBSH-MQCL dynamics [2], etc.
 * And in principle, it can be straightforwardly applied to any mixed
 * quantum-calssical dynamics that defined in QCDyn, only if full density
 * matrice starting from any possible initial states can be provided.
 *
 * Unlike other trajectory-based Dynamics, TTM is more like a post-processing,
 * black-box tool used to propagate the density matrix to arbitrarily long time.
 *
 * Reference:
 * [1] J. Cerrillo, J. Cao, Phys. Rev. Lett. 2014, 112, 110401.
 * [2] A. A. Kananenka, C.-Y. Hsieh, J. Cao, E. Geva, J. Phys. Chem. Let. 2016, 7, 4809.
 */
class DynamicsTTM {
public:
    /**
     * Construct a DynamicsTTM object.
     *
     * This constructor is used in the case that the input denisty matrice for
     * learning are provided from external files.
     *
     * @param param   the global paramters
     */
    DynamicsTTM(Parameters& param) : param(param) {}
    /**
     * Construct a DynamicsTTM object.
     *
     * This constructor is used for post-processing directly after a simulation
     * finished and the reduced denisty matrix produced by previous dynamics
     * simulation are stored in memory.
     *
     * @param param     the global paramters
     * @param RDM_input the input density matrix used for learning
     */
    DynamicsTTM(Parameters& param, std::vector<Complex_Matrix> RDM_input) : param(param), RDM_input(RDM_input) {}
    ~DynamicsTTM() {}
    /**
     * Initialize data members and check the legality of parameters.
     */
    void init();
    /**
     * Load the short time denisty matrice (input) from external files.
     *
     * The results will be stored into RDM_input.
     */
    void loadDensityMatrix();
    /**
     * Construct the dynamical maps from input denisty matrice (RDM_input).
     */
    void buildDynamicalMaps();
    /**
     * Construct the non-Markovian transfer tensors from dynamical maps.
     */
    void buildTransferTensors();
    /**
     * Propagate the density matrix with nsteps.
     */
    void propagate();
    /**
     * Get the electronic reduced density matrix (RDM), which is predicted by
     * TTM method.
     *
     * @return the constant reference to the RDM_output
     */
    const std::vector<Complex_Matrix>& getDensityMatrix() const {
        return RDM_output;
    }

private:
    // Parameters object controls the simulation
    Parameters& param;
    // electronic DOF = number of states/topologies/surfaces.
    // DOFe should be greater than 1.
    int DOFe;
    // the time step size used to propagate. when real unit is used, the unit of it is ps.
    // the time step of learing period and propagatation by TTM should be same.
    // But this consistensy won't be checked in code now. Since the propagation is
    // based on the step not the time. And the value of DT is only used for output.
    double DT;
    // total steps for propatation denisty matrix, including the steps from
    // learning period. So, nsteps should be > k_max.
    int nsteps;
    // the number of steps that read from input density matrix (learning period),
    // which decides length of dynamical maps and transfer tensors.
    int k_max;
    // the index of non-zero (1) element in initial denisty matrix (rho(0)).
    // here, init_state = a*DOFe+b, where a, b is the subscripts of rho.
    // Note, this the init_state rho(0) used for propagation by TTM.
    // If init_state=all, then all possible initial states are considered.
    std::vector<int> init_state;
    // RDM_input stores the reduced electronic density matrice (short time) as
    // input for the TTM method to build dynamical maps. It is a vector of matrix.
    // RDM_input[i][t][f], i is the index of non-zero element in rho(0), t is the
    // step (time = DT*step), and f is the index of element in rho(t).
    // Here, i and f is, i/f = a*DOFe+b, where a, b is the subscripts of rho.
    // The data can be loaded from external files or memory (produced by previous dynamics).
    std::vector<Complex_Matrix> RDM_input;
    // DM is the dynamical maps, and TT is the transfer tensors. (Îµ and T in paper)
    // Both of them are a vector of DOFe^2*DOFe^2 matrix.
    // And the size/length of them is k_max+1: 0,1,2,...,k_max
    // Note the element 0 of DM and TT is useless in the propagation.
    // Here, the value (complex) of DM[k][f][i] is the element of input density
    // matrix at step k, with final state f (rho(t)) and inital state i (rho(0)),
    // in which i/f = a*DOFe+b, where a, b is the subscripts of rho.
    // And TT is constructed iteratively from DM, (see buildTransferTensors()).
    std::vector<Complex_Matrix> DM, TT;
    // RDM_output stores the reduced electronic density matrix of each step.
    // RDM is a vector of vector of complex, each element of it is
    // the density matrix of one step (stored as DOFe^2-dimentional vector).
    // If init_state=all, all RDMs starting from all possible initial states
    // will be calculated by TTM, same format used as RDM_input.
    std::vector<Complex_Matrix> RDM_output;
};